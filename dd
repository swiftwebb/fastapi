

from jose import JWTError, jwt
from datetime import datetime, timedelta
from . import schemas
from fastapi import Depends, status, HTTPException
from fastapi.security import OAuth2PasswordBearer

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")

SECRET_KEY = "12324243jgfkgudyuasjcftakwdy52167431327438ghvcakfgdwhev127253817543jhvahkjv"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30
REFRESH_TOKEN_EXPIRE_DAYS = 30  # long-lived

def _encode(payload: dict, minutes: int = None, days: int = None):
    to_encode = payload.copy()
    if minutes is not None:
        expire = datetime.utcnow() + timedelta(minutes=minutes)
    elif days is not None:
        expire = datetime.utcnow() + timedelta(days=days)
    else:
        raise ValueError("Provide minutes or days for expiration.")
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

def create_access_token(*, user_id: int):
    # include a 'type' claim so we can distinguish tokens
    return _encode({"user_id": user_id, "type": "access"}, minutes=ACCESS_TOKEN_EXPIRE_MINUTES)

def create_refresh_token(*, user_id: int):
    # long-lived token; could also add a 'jti' for DB-backed revocation/rotation
    return _encode({"user_id": user_id, "type": "refresh"}, days=REFRESH_TOKEN_EXPIRE_DAYS)

def verify_access_token(token: str, credentials_exception):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        if payload.get("type") != "access":
            raise credentials_exception
        user_id = payload.get("user_id")
        if user_id is None:
            raise credentials_exception
        token_data = schemas.TokenData(id=user_id)
    except JWTError:
        raise credentials_exception
    return token_data

def verify_refresh_token(token: str):
    cred_exc = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Invalid refresh token",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        if payload.get("type") != "refresh":
            raise cred_exc
        user_id = payload.get("user_id")
        if user_id is None:
            raise cred_exc
        return schemas.TokenData(id=user_id)
    except JWTError:
        raise cred_exc

def get_current_user(token: str = Depends(oauth2_scheme)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    return verify_access_token(token, credentials_exception)























from pydantic import BaseModel, EmailStr
from datetime import datetime
from typing import Optional

# ...your existing code...

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenPair(BaseModel):
    access_token: str
    token_type: str = "bearer"
    # we also return refresh_token for API clients; mobile/web can rely on cookie only
    refresh_token: Optional[str] = None

class TokenData(BaseModel):
    id: int | None = None  # <-- make this int to match your DB IDs



















from fastapi import APIRouter, Depends, status, HTTPException, Response, Cookie
from fastapi.security.oauth2 import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from .. import database, schemas, models, utils, oauth2

router = APIRouter(tags=['Authentication'])

REFRESH_COOKIE_NAME = "refresh_token"
COOKIE_SECURE = True          # True in production (HTTPS). For local HTTP testing, you can temporarily set False.
COOKIE_SAMESITE = "lax"       # or "none" (requires HTTPS)
COOKIE_MAX_AGE = 60 * 60 * 24 * 30  # 30 days

@router.post("/login", response_model=schemas.TokenPair)
def login(
    response: Response,
    user_credentials: OAuth2PasswordRequestForm = Depends(),
    db: Session = Depends(database.get_db),
):
    user = db.query(models.User).filter(models.User.email == user_credentials.username).first()
    if not user or not utils.verify(user_credentials.password, user.password):
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Invalid Credentials")

    access_token = oauth2.create_access_token(user_id=user.id)
    refresh_token = oauth2.create_refresh_token(user_id=user.id)

    # Set refresh token as HttpOnly cookie
    response.set_cookie(
        key=REFRESH_COOKIE_NAME,
        value=refresh_token,
        httponly=True,
        secure=COOKIE_SECURE,
        samesite=COOKIE_SAMESITE,
        max_age=COOKIE_MAX_AGE,
        expires=COOKIE_MAX_AGE,
        path="/",  # optionally narrow to /refresh, /logout, etc.
    )

    # Also return it in body for API clients (optional)
    return {"access_token": access_token, "token_type": "bearer", "refresh_token": refresh_token}

@router.post("/refresh", response_model=schemas.TokenPair)
def refresh(
    response: Response,
    refresh_cookie: str | None = Cookie(default=None, alias=REFRESH_COOKIE_NAME),
    body: dict | None = None,  # allow mobile/clients to send {"refresh_token": "..."} if not using cookies
):
    # Prefer cookie; fall back to body
    refresh_token = refresh_cookie or (body or {}).get("refresh_token")
    if not refresh_token:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Missing refresh token")

    token_data = oauth2.verify_refresh_token(refresh_token)

    # Issue a new access token
    new_access = oauth2.create_access_token(user_id=token_data.id)

    # (Optional but recommended) rotate refresh token
    new_refresh = oauth2.create_refresh_token(user_id=token_data.id)
    response.set_cookie(
        key=REFRESH_COOKIE_NAME,
        value=new_refresh,
        httponly=True,
        secure=COOKIE_SECURE,
        samesite=COOKIE_SAMESITE,
        max_age=COOKIE_MAX_AGE,
        expires=COOKIE_MAX_AGE,
        path="/",
    )

    return {"access_token": new_access, "token_type": "bearer", "refresh_token": new_refresh}

@router.post("/logout", status_code=status.HTTP_204_NO_CONTENT)
def logout(response: Response):
    # Clear the refresh cookie
    response.delete_cookie(
        key=REFRESH_COOKIE_NAME,
        path="/",
    )
    return Response(status_code=status.HTTP_204_NO_CONTENT)
